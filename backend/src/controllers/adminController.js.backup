// src/controllers/adminController.js
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

// Get admin dashboard stats with advanced analytics
const getDashboardStats = async (req, res) => {
  try {
    // Basic stats
    const totalUsers = await prisma.user.count();
    const journalEntries = await prisma.journalEntry.count();
    const breathingSessions = await prisma.breathingSession.count();

    // Time-based analysis
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const twentyFourHoursAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);

    // Active users by time period
    const activeUsers30Days = await prisma.user.count({
      where: { updatedAt: { gte: thirtyDaysAgo } }
    });

    const activeUsers7Days = await prisma.user.count({
      where: { updatedAt: { gte: sevenDaysAgo } }
    });

    const activeUsers24Hours = await prisma.user.count({
      where: { updatedAt: { gte: twentyFourHoursAgo } }
    });

    // Growth trends (last 7 days)
    const dailyGrowth = await Promise.all(
      Array.from({ length: 7 }, async (_, i) => {
        const date = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
        const startOfDay = new Date(date.setHours(0, 0, 0, 0));
        const endOfDay = new Date(date.setHours(23, 59, 59, 999));

        const [newUsers, journalCount, breathingCount] = await Promise.all([
          prisma.user.count({
            where: { createdAt: { gte: startOfDay, lte: endOfDay } }
          }),
          prisma.journalEntry.count({
            where: { createdAt: { gte: startOfDay, lte: endOfDay } }
          }),
          prisma.breathingSession.count({
            where: { createdAt: { gte: startOfDay, lte: endOfDay } }
          })
        ]);

        return {
          date: startOfDay.toISOString().split('T')[0],
          newUsers,
          journalEntries: journalCount,
          breathingSessions: breathingCount,
          totalActivity: journalCount + breathingCount
        };
      })
    );

    // Most active users
    const mostActiveUsers = await prisma.user.findMany({
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        createdAt: true,
        _count: {
          select: {
            journalEntries: true,
            breathingSessions: true
          }
        }
      },
      orderBy: [
        { journalEntries: { _count: 'desc' } },
        { breathingSessions: { _count: 'desc' } }
      ],
      take: 10
    });

    // Calculate activity scores
    const usersWithScores = mostActiveUsers.map(user => ({
      ...user,
      activityScore: user._count.journalEntries * 2 + user._count.breathingSessions,
      totalActivities: user._count.journalEntries + user._count.breathingSessions
    }));

    // Platform health metrics
    const avgActivitiesPerUser = totalUsers > 0 ? 
      Math.round((journalEntries + breathingSessions) / totalUsers * 100) / 100 : 0;

    const engagementRate = totalUsers > 0 ? 
      Math.round((activeUsers30Days / totalUsers) * 100) : 0;

    // Recent activity (last 24 hours)
    const recentJournals = await prisma.journalEntry.count({
      where: { createdAt: { gte: twentyFourHoursAgo } }
    });

    const recentBreathing = await prisma.breathingSession.count({
      where: { createdAt: { gte: twentyFourHoursAgo } }
    });

    res.json({
      // Basic stats
      totalUsers,
      journalEntries,
      breathingSessions,
      
      // Activity metrics
      activeUsers: {
        last24Hours: activeUsers24Hours,
        last7Days: activeUsers7Days,
        last30Days: activeUsers30Days
      },
      
      // Analytics
      analytics: {
        avgActivitiesPerUser,
        engagementRate,
        dailyGrowth: dailyGrowth.reverse()
      },
      
      // Recent activity
      recentActivity: {
        journalEntries: recentJournals,
        breathingSessions: recentBreathing,
        total: recentJournals + recentBreathing
      },
      
      // Top users
      mostActiveUsers: usersWithScores,
      
      // System health
      systemHealth: {
        status: totalUsers > 0 && (journalEntries + breathingSessions) > 0 ? 'healthy' : 'growing',
        totalActivity: journalEntries + breathingSessions,
        avgDailyActivity: Math.round((recentJournals + recentBreathing) * 100) / 100
      }
    });

  } catch (error) {
    console.error('Get dashboard stats error:', error);
    res.status(500).json({ error: 'Failed to get dashboard stats' });
  }
};

// Get all users with enhanced details
const getAllUsers = async (req, res) => {
  try {
    const users = await prisma.user.findMany({
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true,
        createdAt: true,
        updatedAt: true,
        _count: {
          select: {
            journalEntries: true,
            breathingSessions: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    // Calculate additional metrics for each user
    const enhancedUsers = users.map(user => {
      const daysSinceRegistration = Math.floor(
        (new Date() - new Date(user.createdAt)) / (1000 * 60 * 60 * 24)
      );
      
      const daysSinceLastActivity = Math.floor(
        (new Date() - new Date(user.updatedAt)) / (1000 * 60 * 60 * 24)
      );

      const totalActivities = user._count.journalEntries + user._count.breathingSessions;
      
      const activityLevel = totalActivities >= 20 ? 'high' : 
                           totalActivities >= 10 ? 'medium' : 
                           totalActivities >= 1 ? 'low' : 'inactive';

      return {
        ...user,
        metrics: {
          daysSinceRegistration,
          daysSinceLastActivity,
          totalActivities,
          activityLevel,
          avgActivitiesPerDay: daysSinceRegistration > 0 ? 
            Math.round((totalActivities / daysSinceRegistration) * 100) / 100 : 0
        }
      };
    });

    res.json({ users: enhancedUsers });
  } catch (error) {
    console.error('Get all users error:', error);
    res.status(500).json({ error: 'Failed to get users' });
  }
};

// Update user role (existing)
const updateUserRole = async (req, res) => {
  try {
    const { id } = req.params;
    const { role } = req.body;

    if (!['USER', 'ADMIN'].includes(role)) {
      return res.status(400).json({ error: 'Invalid role' });
    }

    const updatedUser = await prisma.user.update({
      where: { id },
      data: { role },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true
      }
    });

    res.json({ user: updatedUser });
  } catch (error) {
    console.error('Update user role error:', error);
    res.status(500).json({ error: 'Failed to update user role' });
  }
};

// Delete user (existing)
const deleteUser = async (req, res) => {
  try {
    const { id } = req.params;

    if (id === req.user.id) {
      return res.status(400).json({ error: 'Cannot delete your own account' });
    }

    await prisma.user.delete({
      where: { id }
    });

    res.json({ message: 'User deleted successfully' });
  } catch (error) {
    console.error('Delete user error:', error);
    res.status(500).json({ error: 'Failed to delete user' });
  }
};

module.exports = {
  getDashboardStats,
  getAllUsers,
  updateUserRole,
  deleteUser
};
